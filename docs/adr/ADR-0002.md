# ADR-0002: Compound Assignment Operators

**Status:** Accepted
**Date:** 2026-01-05

## Context

Neon currently supports standard assignment (`=`) but lacks compound assignment operators (`+=`, `-=`, `*=`, `/=`, `%=`). This is a standard feature in most modern languages that improves code conciseness.

Users currently write:
```neon
count = count + 1
offset = offset * 2
```

They want to write:
```neon
count += 1
offset *= 2
```

## Decision

We will implement compound assignment operators as **syntactic sugar** for variable assignment in the scanner and parser.

For the initial implementation (Phase 1), we will restrict this to **variables only**, matching the current limitation of `PostfixIncrement` (`++`, `--`).

### Implementation Details

**1. Token Support**
We will add new token types:
- `PlusEqual` (`+=`)
- `MinusEqual` (`-=`)
- `StarEqual` (`*=`)
- `SlashEqual` (`/=`)
- `PercentEqual` (`%=`)

**2. Parser Desugaring**
Instead of adding a new `CompoundAssign` node to the AST, we will desugar these operations directly in the parser's `variable()` method.

When the parser encounters `IDENTIFIER += EXPR`, it will generate the AST for `IDENTIFIER = IDENTIFIER + EXPR`.

Transformed AST:
```rust
Expr::Assign {
    name: "x",
    value: Expr::Binary {
        left: Expr::Variable("x"),
        operator: BinaryOp::Add,
        right: Expr(1)
    }
}
```

**3. Scope Limitation**
This feature will **only** support variables (`x += 1`).
It will **not** support complex L-values like:
- Fields (`obj.x += 1`)
- Indices (`arr[i] += 1`)

Supporting complex L-values via desugaring requires temporary variable management (to avoid double-evaluation of the target), or new VM opcodes (`Dup`), which is out of scope for this "Small" feature.

## Consequences

### Positive
- **Zero Codegen/VM Changes**: The AST remains unchanged; the VM needs no new instructions.
- **Low Complexity**: Confined entirely to Scanner and Parser.
- **Immediate Value**: Solves the most common use case (counters, accumulators).

### Negative
- **Limited Scope**: Users might be surprised that `arr[0] += 1` doesn't work yet.
- **Error Messages**: Runtime errors will point to the desugared binary operation, which might slightly confuse users if they expect a specific "compound assignment" error (though likely minor).

## Alternatives Considered

### Alternative 1: First-Class AST Node
Add `Expr::CompoundAssign` and handle it in `codegen.rs`.
- **Pros**: Clearer semantic representation; allows optimized bytecode later.
- **Cons**: Requires touching AST, Semantic Analysis, and Codegen. Overkill for variables-only support.

### Alternative 2: Full Support (Fields/Indices)
Implement complex L-value support immediately.
- **Pros**: Complete feature set.
- **Cons**: Requires either `Dup` opcodes in VM (architectural change) or complex AST desugaring with temporary variables (e.g., `arr[i] += 1` -> `val _tmp = arr; val _idx = i; _tmp[_idx] = _tmp[_idx] + 1`). This is significantly higher effort.

## Implementation Plan

### Phase 1: Scanner & Tokens
- Files: `src/compiler/token.rs`, `src/compiler/scanner.rs`
- Tasks: Add 5 new token types and scan them.

### Phase 2: Parser Desugaring
- Files: `src/compiler/parser.rs`
- Tasks: Update `variable()` to match compound operators and construct `Expr::Assign` with `Expr::Binary` value.

### Phase 3: Testing
- Files: `tests/scripts/compound_assignment.n`
- Tasks: Verify precedence, associativity, and correct value updates.

### Dependencies
None.
