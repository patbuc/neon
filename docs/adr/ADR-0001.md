# ADR-0001: Default Function Parameters

**Status**: Accepted

**Date**: 2026-01-05

## Context

Neon currently requires all function parameters to be provided at call-time. This leads to verbose code when functions have optional configuration or commonly-used default values. For example:

```neon
fn greet(name, greeting, punctuation) {
    print(greeting + " " + name + punctuation)
}
greet("Alice", "Hello", "!")
greet("Bob", "Hello", "!")  // Must repeat "Hello" and "!"
```

Default parameters would allow:

```neon
fn greet(name, greeting = "Hello", punctuation = "!") {
    print(greeting + " " + name + punctuation)
}
greet("Alice")              // Uses defaults
greet("Bob", "Hi")          // Overrides greeting, uses default punctuation
```

This feature aligns with Neon's goal of educational clarity while providing practical expressiveness.

### Architectural Question

How should default parameter values be represented, stored, and evaluated in Neon's compilation pipeline?

Key considerations:
- **AST representation**: How to store both parameter name and optional default expression?
- **Evaluation timing**: When to evaluate defaults (definition-time vs call-time)?
- **Arity semantics**: How to validate argument counts with variable arity?
- **Stack management**: Where to insert default values in the calling convention?

## Decision

We will implement **definition-time evaluated defaults** with the following design:

### 1. AST Representation
Change `Stmt::Fn` to store parameters as `Vec<(String, Option<Expr>)>`, where `Option<Expr>` represents an optional default value expression.

### 2. Evaluation Timing
Evaluate default expressions **at function definition time** (when the `fn` statement executes), not at call time. This is simpler and aligns with Neon's educational focus.

### 3. Storage in ObjFunction
Extend `ObjFunction` to include:
```rust
pub struct ObjFunction {
    pub name: String,
    pub arity: u8,                    // Total parameters (including optional)
    pub min_arity: u8,                // Minimum required parameters
    pub defaults: Vec<Option<Value>>, // Pre-evaluated default values
    pub chunk: Rc<Chunk>,
}
```

### 4. Call-Time Behavior
Modify `call_function()` in VM to:
- Validate `arg_count >= min_arity && arg_count <= arity`
- Push default values onto the stack for any missing arguments
- Proceed with normal call frame setup

### 5. Syntax and Validation Rules
- Syntax: `fn name(required, optional = expr, ...)`
- Rule: Once a parameter has a default, all subsequent parameters must have defaults
- Rule: Default expressions can only reference globals and previously defined parameters
- Rule: Default expressions cannot be self-referential

### Rationale

**Why definition-time evaluation?**
- Simpler implementation: no need to store AST expressions in function objects
- Predictable behavior: defaults are constants, not re-evaluated on each call
- Fits educational goals: easier to understand and explain

**Why store in ObjFunction?**
- Keeps VM calling logic simple: just push values from the defaults array
- No changes needed to bytecode format or chunk structure
- Clear separation: function object owns its calling contract

**Why allow only "trailing" defaults?**
- Matches most language conventions (Python, JavaScript, C++, etc.)
- Simplifies arity checking: single contiguous range [min_arity, arity]
- Avoids ambiguity in argument matching

## Consequences

### Positive
- More expressive function declarations without boilerplate
- Maintains stack-based VM simplicity
- Clear, predictable semantics (definition-time evaluation)
- No new opcodes required
- Compatible with existing function call infrastructure
- Aligns with common language conventions

### Negative
- Default values are fixed at definition time (can't reference later-defined globals)
- Slightly larger `ObjFunction` objects (additional fields)
- Cannot have "middle" optional parameters (positional-only limitation)
- Defaults must be simple expressions (no complex closures)

## Alternatives Considered

### Alternative 1: Call-Time Evaluation
**Description**: Store default expressions as AST nodes in the function object and evaluate them each time the function is called with missing arguments.

**Pros**:
- Defaults can depend on mutable state
- More flexible (defaults can be complex computations)

**Cons**:
- Requires storing AST in function objects (breaks compilation pipeline)
- Significantly more complex implementation
- Performance overhead on every call
- Unclear scoping for default expressions
- Violates educational clarity principle

**Why rejected**: Complexity outweighs benefits for an educational language.

### Alternative 2: Bytecode Initialization Prologue
**Description**: Emit bytecode at the start of each function to check argument count and initialize missing parameters.

**Pros**:
- No changes to `ObjFunction` structure
- Evaluation logic lives in bytecode (unified with other code)

**Cons**:
- Complicates every function's bytecode
- Arity checking still needs VM-level support
- Harder to disassemble/debug
- Requires new opcodes for conditional initialization
- More bytecode bloat

**Why rejected**: Adds complexity to bytecode without clear architectural benefits.

### Alternative 3: Named/Keyword Parameters
**Description**: Allow `func(name="value")` syntax to skip positional requirements.

**Pros**:
- Maximum flexibility (any parameter can be optional)
- Common in modern languages (Python, Swift, Kotlin)

**Cons**:
- Requires argument name parsing at call sites
- Significantly more complex VM calling convention
- Breaks stack-based simplicity
- Out of scope for current educational goals

**Why rejected**: Too complex for initial implementation. Could be future work.

## Related ADRs
- (None yet - this is the first ADR)

## Supersedes / Superseded By
- (None)
