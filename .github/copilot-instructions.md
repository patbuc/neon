# Neon Compiler & VM Custom Instructions

## Project Overview
Neon is an educational compiler and VM project written in Rust. The goal is learning compiler construction and VM implementation, not production use. The project is inspired by Crafting Interpreters but takes its own path.

## Architecture

### Compiler Pipeline
The compilation follows these stages:
1. **Scanner** (`src/compiler/scanner.rs`) - Lexical analysis, produces tokens
2. **Parser** (`src/compiler/parser.rs`) - Syntax analysis, produces AST (`src/compiler/ast/`)
3. **Semantic Analysis** (`src/compiler/semantic.rs`) - Type checking, symbol resolution (`src/compiler/symbol_table.rs`)
4. **Code Generation** (`src/compiler/codegen.rs`) - Emits bytecode to "bloq" format

### VM Runtime
- **VM Core** (`src/vm/impl.rs`) - Stack-based bytecode interpreter
- **Opcodes** (`src/common/opcodes.rs`) - Bytecode instruction set
- **Bloq Format** (`src/common/bloq/`) - Custom bytecode format with constants pool and disassembler
- **Functions** (`src/vm/functions.rs`) - Function call handling

### Key Modules
- `src/common/` - Shared types, errors, opcodes, bloq format
- `src/compiler/` - Frontend (lexing, parsing, semantic analysis, codegen)
- `src/vm/` - Backend (bytecode execution)
- `src/wasm.rs` - WebAssembly bindings for browser execution

## Code Style & Conventions

### Rust-Specific
- Prefer explicit error types over `unwrap()` - use proper error propagation with `Result<T, E>`
- Use pattern matching extensively for AST traversal and opcode handling
- Leverage Rust's ownership system - avoid unnecessary clones in hot paths (VM execution loop)
- Use `tracing` crate for logging, not `println!` for debugging

### Compiler/VM Patterns
- **Opcodes**: Keep instruction set minimal and orthogonal - avoid redundant instructions
- **Stack Operations**: VM is stack-based - always maintain stack invariants in comments
- **Symbol Tables**: Use scoped symbol tables with proper lexical scoping
- **Error Reporting**: Include line/column info from tokens for user-friendly compile errors (`src/common/error_renderer.rs`)
- **Bytecode**: Treat bytecode as append-only during emission - no back-patching unless explicitly for jump addresses

### Testing Requirements
- All compiler stages must have unit tests in `src/compiler/tests/`
- VM operations must have integration tests in `src/vm/tests/`
- Add end-to-end tests in `tests/` directory using `datatest-stable` harness
- Test error paths and edge cases (empty input, malformed bytecode, stack overflow)

### Performance Considerations
- VM execution loop is hot path - minimize allocations
- Use `Vec` pre-allocation when final size is known
- Avoid string allocations in tokenization - use string slices where possible
- Consider using `SmallVec` for frequently-allocated small collections (e.g., function arguments)

## Build & Test
- Build: `cargo build`
- Test: `cargo test`
- Run: `cargo run -- <script.n>`
- WASM: `./build-wasm.sh` (builds for browser)
- Disassembly: Enable with `--features disassemble`

## Common Tasks

### Adding a New Opcode
1. Add opcode constant to `src/common/opcodes.rs`
2. Update VM execution loop in `src/vm/impl.rs`
3. Update codegen to emit it in `src/compiler/codegen.rs`
4. Add disassembler support in `src/common/bloq/disassembler.rs`
5. Write tests for compilation and execution

### Adding New Language Feature
1. Add token types to `src/compiler/token.rs` if needed
2. Update scanner regex/logic in `src/compiler/scanner.rs`
3. Extend AST nodes in `src/compiler/ast/mod.rs`
4. Update parser with grammar rules in `src/compiler/parser.rs`
5. Add semantic validation in `src/compiler/semantic.rs`
6. Implement codegen in `src/compiler/codegen.rs`
7. Add comprehensive tests at each layer

### Debugging VM Issues
- Use `disassemble` feature to inspect generated bytecode
- Check stack state before/after instruction execution
- Verify constants pool contains expected values
- Trace execution with `tracing::debug!` in VM loop

## Anti-Patterns to Avoid
- Don't add features without educational value - this is a learning project
- Don't over-optimize prematurely - clarity over performance
- Don't skip intermediate representation steps - make the pipeline explicit
- Don't hide compiler errors - make them verbose and helpful
- Don't write production-grade code - favor readability and learning
